<#@ template hostspecific="true" language="C#" #>
<#@ include file="../SharedT4/SaveOutput.tt" #>
<#@ include file="SingleFile.tt" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="System.ComponentModel.DataAnnotations.dll" #>
<#@ assembly name="$(SolutionDir)\ModelTranslator\bin\Debug\ModelTranslator.dll" #>
<#@ assembly name="$(SolutionDir)\Burnsba.Data\bin\Debug\Burnsba.Data.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Linq.Expressions" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.ComponentModel.DataAnnotations" #>
<#@ import namespace="Burnsba.Data.Database" #>
<#@ import namespace="ModelTranslator" #>
<#@ import namespace="ModelTranslator.Attributes" #>
<#@ import namespace="ModelTranslator.Utilities" #>
<#
		/*
			This template is used to create an XSL translation to convert a resume from XML to HTML
		*/
		// config settings (more below)
	
		//string PathSeperator = "/";
		string outputDirectory = this.Host.ResolvePath(".");
		string editorFileNameFormat = "ResumeToHtml.{0}";
		string extension = "xslt";

		try
		{
			outputDirectory = Path.Combine(outputDirectory, "Xslt");
		}
		catch (Exception ex)
		{
			return "//" + ex.Message;
		}

		// clear any text before this point (should just be whitespace)
		this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
		WriteLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
		WriteLine("<!--");
#>
// <autogenerated>
// This code was generated by a tool. Any changes made manually will be lost
// the next time this code is regenerated.
// 
// Build date: <#Write(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss \"GMT\"zzz") + "\r\n");#>
// </autogenerated>
<#
		WriteLine("-->");

		generateOutput();

		string outputName = String.Format(editorFileNameFormat, extension);
		SaveOutput(Path.Combine(outputDirectory, outputName));
#>


<#+
	// more config settings
	private const string PathSeperator = "/";
	
    private void XmlToHtmlInternalFormat(Type modelType, int level, string propertyPath, int indentLevel, int headingLevel)
	{
		string propertyPrefix = String.IsNullOrEmpty(propertyPath) ? "" : propertyPath;
		
		// to prevent infinite run-away, terminate recursion at 10 levels.
		if (level > 10)
		{
			throw new OverflowException("Excessive Recursion.  Please review data model type.");
		}

		List<PropertyInfo> properties = Reflection.GetProperties(modelType);

		// attempt to put lists and things at the end of each section
		properties = properties.OrderBy(x => x.PropertyType.Name.ToLower().Contains("collection")).ToList();
		
		// go over all the properties found
		foreach (PropertyInfo propertyInfo in properties)
		{
			// Check for attributes to see if this is used. If the property is to be exported to the viewmodel
			// but not the view, the sub-properties still need to be evaluated in case any of those will
			// be used in the view.
			if(!Attribute.IsDefined(propertyInfo, typeof(ExportToViewModel)) && !Attribute.IsDefined(propertyInfo, typeof(ExportToView)))
            {
				continue;
            }

			// simple data types and types that have a defined display value do not need to be recursed.
			bool stopRecursion = false;

			// need to check for lists to prevent recursion on collection types
			bool isList = Reflection.IsList(propertyInfo.PropertyType);
			string listSeperator = ",";

			// default property label. Can be over written with attribute [Display(Name = "...")]
			string propertyDisplay = propertyInfo.Name;

			// path to property to use in view display
			string propertyDisplayPath = String.Empty;

			// Need to track if this is a property marked with export to view model attribute but not view; then
			// children properties will be recursed but this property won't be output.
			bool isHidden = false;

            bool isGeneric = false;
            Type underlyingType = propertyInfo.PropertyType;

			//  Default editor is property fullname if no attributes are set
			string fullName = propertyInfo.PropertyType.FullName;

			// prepend any path information if this is inside a recursive call
			string fullPropertyPath = String.IsNullOrEmpty(propertyPrefix)
				? propertyInfo.Name
				: propertyPrefix + propertyInfo.Name;

            if (Reflection.IsSimpleGeneric(propertyInfo.PropertyType))
            {
                underlyingType = Reflection.GetSimpleGenericUnderlying(propertyInfo.PropertyType);

				fullName = underlyingType.FullName;
            }

			// check for display attributes
			List<ViewDisplay> displayAttributes = Reflection.GetPropertyAttributes<ViewDisplay>(propertyInfo);
							
			if (displayAttributes.Count() > 0)
			{
				if (displayAttributes.First().HasDisplayName)
				{
					propertyDisplay = displayAttributes.First().DisplayName;
				}

				if (displayAttributes.First().ListDisplayHint == ListHint.UseSeperator)
                {
					listSeperator = displayAttributes.First().ListSeperator;
					stopRecursion = true;
                }
			}

            if (Reflection.GetPropertyAttributes<ExportToView>(propertyInfo).Count() <= 0)
			{
				// no ExportToView attribute
				isHidden = true;
            }


			bool hasPropertyDisplayPath = false;
			string s = String.Empty;
			hasPropertyDisplayPath = PropertyPath.TryGetViewDisplayPath(underlyingType, "/", out s);
			if (hasPropertyDisplayPath)
            {
				propertyDisplayPath = s;
				// does this need to stop recursion?
				//stopRecursion = true;
            }

			// is this a simple builtin type?
			switch (fullName.ToLower())
			{
				// some basic .NET types have child properties, but these shouldn't be recursed.
				case "system.string": /* fall through */
				case "system.datetime":
				case "system.guid":
					stopRecursion = true;
					break;
				default:
					break;
			}

			// decide whether to recurse or output.
			if (stopRecursion)
            {
				if (!isHidden && !isList)
                {
					PropertyWriterHelper(fullName.ToLower(), propertyDisplay, fullPropertyPath, indentLevel);
                }
				else if (isList)
                {
                    ListAtomicWriterHelper(propertyInfo.Name, propertyDisplay, propertyDisplayPath, listSeperator, indentLevel, headingLevel);
                }
            }
			else
            {
				if (isList && underlyingType != null)
                {
					ListPropertyWriterHelperOpen(fullPropertyPath, propertyDisplay, indentLevel, headingLevel);
					indentLevel += 1;
                    XmlToHtmlInternalFormat(underlyingType, level + 1, "", indentLevel + 1, headingLevel + 1);
					indentLevel -= 1;
					ListPropertyWriterHelperClose(indentLevel);
                }
				else
                {
					XmlToHtmlInternalFormat(propertyInfo.PropertyType, level + 1, fullPropertyPath + PathSeperator, indentLevel, headingLevel);
                }
            }
		}

	}

	private string IndentToSpace(int indent)
    {
		string output = String.Empty;

		for(int i=0; i<indent*2; i++)
        {
			output += " ";
        }

		return output;
    }

	private void ListAtomicWriterHelper(string currentPropertyPath, string currentPropertyDisplay, string pathToDisplayProperty, string listSeperator, int indentLevel, int headingLevel)
    {
		WriteLine(String.Format("{0}<xsl:if test=\"{1}\">", IndentToSpace(indentLevel), currentPropertyPath));

		WriteLine(String.Format("{0}<div class=\"resume-group\">", IndentToSpace(indentLevel+1)));
		WriteLine(String.Format("{0}<div class=\"resume-group-title\"><h{2}>{1}</h{2}></div>", IndentToSpace(indentLevel+2), currentPropertyDisplay, headingLevel));
		
		

		WriteLine(String.Format("{0}<div class=\"resume-group-content\">", IndentToSpace(indentLevel+2)));
		WriteLine(String.Format("{0}<xsl:for-each select=\"{1}\">", IndentToSpace(indentLevel+3), currentPropertyPath));

		WriteLine(String.Format("{0}<xsl:value-of select=\"{1}\" />", IndentToSpace(indentLevel+4), pathToDisplayProperty));
		WriteLine(String.Format("{0}<xsl:if test=\"position() != last()\" xml:space=\"preserve\">{1} </xsl:if>", IndentToSpace(indentLevel+4), listSeperator));

		WriteLine(String.Format("{0}</xsl:for-each>", IndentToSpace(indentLevel+3)));
		WriteLine(String.Format("{0}</div>", IndentToSpace(indentLevel+2)));
		
		WriteLine(String.Format("{0}</div>", IndentToSpace(indentLevel+1)));

		WriteLine(String.Format("{0}</xsl:if>", IndentToSpace(indentLevel)));
    }

	private void ListPropertyWriterHelperOpen(string xslPropertyPath, string groupTitle, int indentLevel, int headingLevel)
    {
		WriteLine("");
		WriteLine(String.Format("{0}<div class=\"resume-group\">", IndentToSpace(indentLevel)));
		WriteLine(String.Format("{0}<div class=\"resume-group-title\"><h{2}>{1}</h{2}></div>", IndentToSpace(indentLevel), groupTitle, headingLevel));
		WriteLine(String.Format("{0}<xsl:for-each select=\"{1}\">", IndentToSpace(indentLevel), xslPropertyPath));
		WriteLine(String.Format("{0}<div class=\"resume-group-content\">", IndentToSpace(indentLevel+1)));
    }
	private void ListPropertyWriterHelperClose(int indentLevel)
    {
		WriteLine(String.Format("{0}</div>", IndentToSpace(indentLevel+1)));
		WriteLine(String.Format("{0}</xsl:for-each>", IndentToSpace(indentLevel)));
		WriteLine(String.Format("{0}</div>", IndentToSpace(indentLevel)));
		WriteLine("");
    }
	
	private void PropertyWriterHelper(string propertyTypeName, string propertyLabel, string xslPropertyPath, int indentLevel)
    {
		string selectText = String.Empty;
		switch(propertyTypeName)
        {
			case "system.datetime":
				selectText = string.Format("select=\"ms:format-date({0}, 'MMM dd, yyyy')\"", xslPropertyPath);
				break;
			default:
				selectText = string.Format("select=\"{0}\"", xslPropertyPath);
				break;
        }

		WriteLine(String.Format("{0}<div><span class=\"left-col\">{1}</span><span class=\"right-col\"><xsl:value-of {2} disable-output-escaping=\"yes\" /></span></div>", IndentToSpace(indentLevel), SplitCamelCase(propertyLabel), selectText));
    }

    // apparently T4 expression support is more limited than regular C#, have to pass in the property
    // type as an argument when making a call.
    // <example>
    //   GetPropertyInfo<Document,string>(x => x.DocumentTitle).Name
    // </example>
    private PropertyInfo GetPropertyInfo<TSource, TProperty>(Expression<Func<TSource, TProperty>> propertyLambda)
    {
        MemberExpression member = propertyLambda.Body as MemberExpression;
        if (member == null)
            throw new ArgumentException(string.Format(
                "Expression '{0}' refers to a method, not a property.",
                propertyLambda.ToString()));

        PropertyInfo propInfo = member.Member as PropertyInfo;
        if (propInfo == null)
            throw new ArgumentException(string.Format(
                "Expression '{0}' refers to a field, not a property.",
                propertyLambda.ToString()));

        return propInfo;
    }

    private void generateOutput()
	{
#>


<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:msxsl="urn:schemas-microsoft-com:xslt"
	xmlns:ms="urn:schemas-microsoft-com:xslt"
    xmlns:dt="urn:schemas-microsoft-com:datatypes"
	exclude-result-prefixes="msxsl"
>
    <xsl:output method="text" encoding="UTF-8"  indent="yes" />

    <xsl:template match="/ResumeRoot">
      <html>
        <head>
          <title>
            <xsl:value-of select="<#+Write( GetPropertyInfo<Document,string>(x => x.DocumentTitle).Name);#>"/>
          </title>
          <style>
            * {
                font-family: Arial;
                font-size: 12px;
            }

            .resume-group {
                padding: 4px;
                margin: 4px;
                margin-left: 2em;
            }
                .resume-group-content {
                margin: 8px;
                border: 1px solid #dddddd;
                padding: 8px;
                margin-left: 20px;
            }
            .resume-group-content:before {
                content: "\25ba";
                font-family: "Times New Roman";
                display: block;
                position: relative;
                left: -28px;
                height: 0px;
                font-size: 18px;
                top: -4px;
            }
            .left-col {
                display: inline-block;
                min-width: 200px;
            }
            .right-col {
                display: inline-block;
            }

            h1 {
                font-size: 16px;
            }

            h2 {
                font-size: 14px;
            }

            h3 {
                font-size: 12px;
                font-weight: bold;
                margin: 0px;
            }
          </style>
        </head>
        <body>

        <div class="resume-group">
			<div class="resume-group">
				<div class="resume-group-title"><h1><xsl:value-of select="<#+Write( GetPropertyInfo<Document,string>(x => x.DocumentTitle).Name);#>" /></h1></div>

				<div>
				  <xsl:value-of select="PersonRoot/<#+Write( GetPropertyInfo<Contact,string>(x => x.FullName).Name);#>"/>
				</div>
				<div>
				  <xsl:value-of select="PersonRoot/<#+Write( GetPropertyInfo<Contact,ICollection<Email>>(x => x.Email).Name);#>[1]/<#+Write( GetPropertyInfo<Email,string>(x => x.EmailAddress).Name);#>"/>
				</div>

			</div>
		</div>

        <!-- set xsl context to document node -->
        <xsl:for-each select=".">
		<div class="resume-group">
<#+ XmlToHtmlInternalFormat(typeof(Document), 0, null, 5, 1); #>
		</div>
        </xsl:for-each>
        </body>
      </html>
    </xsl:template>

</xsl:stylesheet>

<#+	
	}
#>